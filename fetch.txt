;the below defines a list of intervals on Tarsh (17 tone per octave in JI)
 <
 @ frets ;define frets
 [[48 48] [57 54] [60 55] [63 56] [57 48] [81 66] [81 64]
 [64 48] [72 51] [80 55] [72 48]
 [95 60] [90 55] [81 48] [96 54] [96 51] [64 33]
 [96 48] [114 54] [120 55] [126 56] [114 48] [108 44] [81 32]
 [88 33] [96 34] [96 33] [120 40]
 [114 36] [108 33] [108 32] [96 27] [64 17] [128 33]]
 >


;extract the numerators from a list of intervals into a new list
;recursively pop the first element in the pairs
 <
 @ nums
 <# [idx]
 <? idx
    <tank <" <" idx>> <nums <: idx>>>
    idx
>
>
>


;extract the denomerators from a list of intervals into a new list
;recursively pop the second element in the pairs
 <
 @ denoms
 <# [idx]
 <? idx <tank <" <: <" idx>>> <denoms <: idx>>> idx>>
 >


;extracts the last n number of elements in a list
;recursively drills to an empty list and bubbles up the last number of elements as set by length
;the elements could be tuples, like a list of intervals
 <@ lastn
 <# [list length]
    <? length
        <? list
            <lastn  <: list>  <- length 1>>
            list
        >
        list
    >
 >
 >


;grabs the first element in the first pair from the lastn list i.e. extracts the numerator in the intervals when counting backwards by length
 <
 @ num
 <# [frets length]
    <? frets
        <tank <" <" frets>> <num <lastn frets length> length>>
        frets
    >
 >
 >


;grabs the denomitor from the fret as specified counting back from the octave
<
@ denom
<# [frets length]
 <? frets
 <tank <" <: <" frets>>> <denom <lastn frets length> length>>
 frets
>
>
>


;generates arpeggios based on the number of steps in the first parameter and the octave in the second
;the steps are spaced by sevenths
;using prim_euro it recursively applies as such: edo(b c d) = d * 2^(b/c). "b" will countdown each cycle until zero.
;produces a list of the form edo(5 7 d)=[(d * 2^(5/7)), (d * 2^(4/7)), (d * 2^(3/7)), (d * 2^(2/7)), (d * 2^(1/7))]
;dividing the exponent of two by seven approximates the seventh harmonic
;there is tone equivalence at every multiple by 2 of a generated value.
;like an EDO generator.
;the sequence that it creates is non-linear due to the rounding to the nearest int
;try interval_denom as 31 and interval_num as 17.
<
@ edo
<# [interval_num interval_denom scaler]
<? interval_num
<tank
<` 2 interval_num interval_denom scaler>
<edo <- interval_num 1> interval_denom scaler>
>
interval_num
>
>
>



;the mapping of steel and brass to frets
(horn 64 48 (steel))
(hornc 96 48 (steelc))
(hornb 72 48 (steelb))
(hornd 88 33 (steeld))
(horne 60 65 (brass))
(hornf 81 66 (brassb))
(horng 90 55 (brassc))
(hornh 96 51 (brassd))



;counts the number of elements in a list
<@ count
    <# [list counter]
        <? <: list>
            <count <: list><+ counter 1>>
            <$ counter>
        >
    >
>
